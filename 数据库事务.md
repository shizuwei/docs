# 数据库事务

### 事务
-----------
#### 事务(Transaction)需要满足四个条件：

1. **Atomicity**  （原子性）一个事务要么完成，要么回滚复原。
2. **Consistency**（稳定性）事务执行前后要保证数据库的一致性，例如：外键约束。
3. **Isolation**  （隔离性）并发执行的多个事务之间是隔离的，不互相干扰。隔离有不同的级别。
4. **Durability** （可靠性）事务提交后，能够永久保存改变，不受故障和其它操作影响。

#### 事务的五种状态：

1. **活动状态**
执行开始还未结束。
2. **部分提交状态**
整个事务的最后一条语句执行完毕。
3. **失败状态**
未能正常执行。
4. **提交状态**
整个事务正常执行并被写入到磁盘。
5. **中止状态**
事务回滚，数据库恢复到执行前的状态。

#### 事务的隔离级别

1. **Read Uncommitted** 读取未提交的数据，例如在缓冲区中的数据，也被称之为脏读（Dirty Read)，实际很少用。
2. **Read Committed** 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
3. **Repeatable Read**  MySQL的默认事务隔离级别。同一事务多次读取时，总是读取第一次的快照，不能看到别的事务的改变，但能看到本事务的改变，除非事务结束，重新开启，才能看到其它事务的改变。可能幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。MVCC就是通过在事务开始时生成快照来实现的。

|:-隔离级别|脏读|
#### 脏读，不可重复读，幻读
1. **脏读** 一个事务会读进还没有被另一个事务提交的数据，所以你会看到一些最后被另一个事务回滚掉的数据。
2. **不可重复读** 一个事务读进一条记录，另一个事务更改了这条记录并提交完毕，这时候第一个事务再次读这条记录时，它已经改变了(删除或更新)。
3. **幻影读** 一个事务用Where子句来检索一个表的数据，另一个事务插入一条新的记录，并且符合Where条件，这样，第一个事务用同一个where条件来检索数据后，就会多出一条记录。在插入时出现。

### MySQL事务
-----------


### Spring中事务
-----------
Spring框架中的事务实现有两种，**编程式实现**或者**AOP声明式实现**。



